---
title: Installation
description: Learn how to install and configure BTST in your project.
---

import { Steps, Step } from "fumadocs-ui/components/steps";
import { Tabs, Tab } from "fumadocs-ui/components/tabs";
import { Callout } from "fumadocs-ui/components/callout";


## Prerequisites

In order to use BTST, your application must meet the following requirements:

- **[shadcn/ui](https://ui.shadcn.com/)** installed with CSS variables enabled - Plugins use shadcn/ui components. To verify CSS variables are enabled, check that your `components.json` has `"cssVariables": true` or your Tailwind config uses CSS variables for colors.
- **[Sonner](https://ui.shadcn.com/docs/components/sonner)** `<Toaster />` component configured for toast notifications
- **[TailwindCSS](https://tailwindcss.com) v4** set up and configured correctly - Plugins use Tailwind classes and utilities
- **[@tanstack/react-query](https://tanstack.com/query)** installed - Required for server-side prefetching and client-side data fetching/state management

<Steps>
  <Step>
    ### Install the Package

    Let's start by adding BTST to your project:

    <Tabs groupId="installation" items={['npm', 'pnpm', 'yarn']} persist>
      <Tab value="npm">
        ```bash
        npm install @btst/stack @tanstack/react-query
        ```
      </Tab>

      <Tab value="pnpm">
        ```bash
        pnpm add @btst/stack @tanstack/react-query
        ```
      </Tab>

      <Tab value="yarn">
        ```bash
        yarn add @btst/stack @tanstack/react-query
        ```
      </Tab>
    </Tabs>

    <Callout type="info">
      BTST plugins require `@tanstack/react-query` for server-side prefetching and client-side data fetching and state management.
    </Callout>
  </Step>

  <Step>
    ### Install Database Adapter

    BTST requires a database adapter to work with your database. Choose one based on your setup:

    <Tabs groupId="adapter-type" items={["prisma", "drizzle", "kysely", "mongodb", "memory"]} persist>
      <Tab value="prisma">
        For Prisma ORM:

        <Tabs groupId="installation" items={['npm', 'pnpm', 'yarn']} persist>
          <Tab value="npm">
            ```bash
            npm install @btst/adapter-prisma
            ```
          </Tab>

          <Tab value="pnpm">
            ```bash
            pnpm add @btst/adapter-prisma
            ```
          </Tab>

          <Tab value="yarn">
            ```bash
            yarn add @btst/adapter-prisma
            ```
          </Tab>
        </Tabs>
      </Tab>

      <Tab value="drizzle">
        For Drizzle ORM:

        <Tabs groupId="installation" items={['npm', 'pnpm', 'yarn']} persist>
          <Tab value="npm">
            ```bash
            npm install @btst/adapter-drizzle
            ```
          </Tab>

          <Tab value="pnpm">
            ```bash
            pnpm add @btst/adapter-drizzle
            ```
          </Tab>

          <Tab value="yarn">
            ```bash
            yarn add @btst/adapter-drizzle
            ```
          </Tab>
        </Tabs>
      </Tab>

      <Tab value="kysely">
        For Kysely query builder:

        <Tabs groupId="installation" items={['npm', 'pnpm', 'yarn']} persist>
          <Tab value="npm">
            ```bash
            npm install @btst/adapter-kysely
            ```
          </Tab>

          <Tab value="pnpm">
            ```bash
            pnpm add @btst/adapter-kysely
            ```
          </Tab>

          <Tab value="yarn">
            ```bash
            yarn add @btst/adapter-kysely
            ```
          </Tab>
        </Tabs>
      </Tab>

      <Tab value="mongodb">
        For MongoDB:

        <Tabs groupId="installation" items={['npm', 'pnpm', 'yarn']} persist>
          <Tab value="npm">
            ```bash
            npm install @btst/adapter-mongodb
            ```
          </Tab>

          <Tab value="pnpm">
            ```bash
            pnpm add @btst/adapter-mongodb
            ```
          </Tab>

          <Tab value="yarn">
            ```bash
            yarn add @btst/adapter-mongodb
            ```
          </Tab>
        </Tabs>
      </Tab>

      <Tab value="memory">
        For development and testing, use the in-memory adapter:

        <Tabs groupId="installation" items={['npm', 'pnpm', 'yarn']} persist>
          <Tab value="npm">
            ```bash
            npm install @btst/adapter-memory
            ```
          </Tab>

          <Tab value="pnpm">
            ```bash
            pnpm add @btst/adapter-memory
            ```
          </Tab>

          <Tab value="yarn">
            ```bash
            yarn add @btst/adapter-memory
            ```
          </Tab>
        </Tabs>
      </Tab>
    </Tabs>
  </Step>

  <Step>
    ### Create Backend Instance

    Create a file named `stack.ts` in your `lib/` folder to configure the backend API:

    <Tabs groupId="adapter-type" items={["prisma", "drizzle", "kysely", "mongodb", "memory"]} persist>
      <Tab value="prisma">
        ```ts title="lib/stack.ts"
        import { stack } from "@btst/stack"
        import { createPrismaAdapter } from "@btst/adapter-prisma"
        import { PrismaClient } from "@prisma/client"

        const prisma = new PrismaClient()

        const { handler, dbSchema } = stack({
          basePath: "/api/data",
          plugins: {
            // Add your backend plugins here
          },
          adapter: (db) => createPrismaAdapter(prisma, db, { 
            provider: "postgresql" // or "mysql", "sqlite", "cockroachdb", "mongodb"
          })
        })

        export { handler, dbSchema }
        ```
      </Tab>

      <Tab value="drizzle">
        ```ts title="lib/stack.ts"
        import { stack } from "@btst/stack"
        import { createDrizzleAdapter } from "@btst/adapter-drizzle"
        import { drizzle } from "drizzle-orm/postgres-js" // or "drizzle-orm/mysql2", "drizzle-orm/better-sqlite3", etc.
        import postgres from "postgres"

        const client = postgres(process.env.DATABASE_URL!)
        const drizzleDb = drizzle(client)

        const { handler, dbSchema } = stack({
          basePath: "/api/data",
          plugins: {
            // Add your backend plugins here
          },
          adapter: (db) => createDrizzleAdapter(drizzleDb, db, {})
        })

        export { handler, dbSchema }
        ```
      </Tab>

      <Tab value="kysely">
        ```ts title="lib/stack.ts"
        import { stack } from "@btst/stack"
        import { createKyselyAdapter } from "@btst/adapter-kysely"
        import { Kysely, PostgresDialect } from "kysely"
        import { Pool } from "pg"

        const kyselyDb = new Kysely({
          dialect: new PostgresDialect({
            pool: new Pool({ connectionString: process.env.DATABASE_URL })
          })
        })

        const { handler, dbSchema } = stack({
          basePath: "/api/data",
          plugins: {
            // Add your backend plugins here
          },
          adapter: (db) => createKyselyAdapter(kyselyDb, db, {})
        })

        export { handler, dbSchema }
        ```
      </Tab>

      <Tab value="mongodb">
        ```ts title="lib/stack.ts"
        import { stack } from "@btst/stack"
        import { createMongodbAdapter } from "@btst/adapter-mongodb"
        import { MongoClient } from "mongodb"

        const client = new MongoClient(process.env.MONGODB_URI!)
        const mongoDb = client.db()

        const { handler, dbSchema } = stack({
          basePath: "/api/data",
          plugins: {
            // Add your backend plugins here
            // blog: blogBackendPlugin()
          },
          adapter: (db) => createMongodbAdapter(mongoDb, db, {})
        })

        export { handler, dbSchema }
        ```
      </Tab>

      <Tab value="memory">
        ```ts title="lib/stack.ts"
        // IMPORTANT: Memory adapter is used for development and testing only
        import { stack } from "@btst/stack"
        import { createMemoryAdapter } from "@btst/adapter-memory"

        const { handler, dbSchema } = stack({
          basePath: "/api/data",
          plugins: {
            // Add your backend plugins here
          },
          adapter: (db) => createMemoryAdapter(db)({})
        })

        export { handler, dbSchema }
        ```
      </Tab>
    </Tabs>

    <Callout type="info">
    **What happens here:**
    - `stack()` collects all plugin database schemas and merges them into a unified `dbSchema`
    - The `basePath` determines where your API is mounted (e.g., `/api/data/*`)
    - The `adapter` function receives this merged schema (`db`) and returns an adapter that translates BTST's database operations to your ORM
    - The `handler` is a request handler function `(request: Request) => Promise<Response>` that processes all API calls
    </Callout>

    **Now you can generate database schema** using the CLI (not needed for mongodb):
      
 <Tabs items={["prisma", "drizzle", "kysely"]}>
  <Tab value="prisma">
    ```bash
    npx @btst/cli generate --config=lib/stack.ts --orm=prisma --output=schema.prisma
    ```
  </Tab>

  <Tab value="drizzle">
    ```bash
    npx @btst/cli generate --config=lib/stack.ts --orm=drizzle --output=src/db/schema.ts
    ```
  </Tab>

  <Tab value="kysely">
    Kysely requires a database connection for introspection:

    **Using DATABASE_URL environment variable:**

    ```bash
    DATABASE_URL=sqlite:./dev.db npx @btst/cli generate --config=lib/stack.ts --orm=kysely --output=migrations/schema.sql
    ```

    **Or using --database-url flag:**

    ```bash
    npx @btst/cli generate --config=lib/stack.ts --orm=kysely --output=migrations/schema.sql --database-url=sqlite:./dev.db
    ```

    ```bash
    npx @btst/cli generate --config=lib/stack.ts --orm=kysely --output=migrations/schema.sql --database-url=postgres://user:pass@localhost:5432/db
    ```
  </Tab>
</Tabs>

    <Callout type="info">
      See the [CLI documentation](/cli) to learn more about generating database schemas and migrations.
    </Callout>
  </Step>

  <Step>
    ### Create API Route

    Create a catch-all API route to handle BTST requests. The route will handle requests for the path `/api/data/*`. If you use a different path make sure to update the `basePath` in the `stack` config to match your chosen path.

    <Tabs  groupId="frameworks" items={["next-js", "react-router", "tanstack", "nodejs"]} persist>
      <Tab value="next-js">
        ```ts title="app/api/data/[[...all]]/route.ts"
        import { handler } from "@/lib/stack"

        export const GET = handler
        export const POST = handler
        export const PUT = handler
        export const DELETE = handler
        ```
      </Tab>

      <Tab value="react-router">
        ```ts title="app/routes/api/data/route.ts"
        import { handler } from "~/lib/stack"
        import type { LoaderFunctionArgs, ActionFunctionArgs } from "@remix-run/node"

        export async function loader({ request }: LoaderFunctionArgs) {
          return handler(request)
        }

        export async function action({ request }: ActionFunctionArgs) {
          return handler(request)
        }
        ```
      </Tab>

      <Tab value="tanstack">
        ```ts title="src/routes/api/data/$.ts"
        import { createFileRoute } from '@tanstack/react-router'
        import { handler } from '@/lib/stack'

        export const Route = createFileRoute('/api/data/$')({
          server: {
            handlers: {
              GET: async ({ request }) => {
                return handler(request)
              },
              POST: async ({ request }) => {
                return handler(request)
              },
              PUT: async ({ request }) => {
                return handler(request)
              },
              DELETE: async ({ request }) => {
                return handler(request)
              },
            },
          },
        })
        ```
      </Tab>

      <Tab value="nodejs">
        For standalone Node.js servers (Express, Fastify, etc.), use `toNodeHandler` to convert the Web API handler to a Node.js-compatible handler:

        ```ts title="server.ts"
        import express from "express"
        import { handler } from "./lib/stack"
        import { toNodeHandler } from "@btst/stack/api"

        const app = express()
        
        // Convert Web API handler to Node.js handler
        const nodeHandler = toNodeHandler(handler)
        
        // Mount at your basePath
        app.use("/api/data", nodeHandler)
        
        app.listen(3000, () => {
          console.log("Server running on http://localhost:3000")
        })
        ```

        **Alternative: Using with Express middleware**

        ```ts title="server.ts"
        import express from "express"
        import { handler } from "./lib/stack"
        import { toNodeHandler } from "@btst/stack/api"

        const app = express()
        app.use(express.json()) // Parse JSON bodies
        
        // Convert and mount BTST handler
        app.all("/api/data/*", toNodeHandler(handler))
        
        app.listen(3000)
        ```
      </Tab>
    </Tabs>
  </Step>


  <Step>
    ### Import Plugin Styles

    Plugins use [TailwindCSS v4](https://tailwindcss.com), so you should add the following `@import` to your global css file to ensure proper styling:

    ```css title="app/globals.css"
    @import "@btst/stack/plugins/blog/css";
    ```

    <Callout type="info">
      Each plugin may require its own CSS import. The import path follows the pattern `@btst/stack/plugins/{plugin-name}/css`. Check the plugin documentation for specific requirements.
    </Callout>
  </Step>

  <Step>
    ### Create Client Instance

    Create a client instance that routes requests to plugin pages, prefetches their data on the server, and renders them with instant hydration on the client:

    ```ts title="lib/stack-client.tsx"
    import { createStackClient } from "@btst/stack/client"
    import { QueryClient } from "@tanstack/react-query"

    export const getStackClient = (queryClient: QueryClient) => {
      return createStackClient({
        plugins: {
          // Add your client plugins here
        }
      })
    }
    ```

    <Callout type="info">
      **Why a function?** `getStackClient` takes a `QueryClient` because different contexts use different instances:
      - **Server (SSR)**: Each request gets its own QueryClient (or cached per-request)
      - **Client**: A singleton QueryClient is shared across navigations
      - **Additional options**: You can pass additional options to the `createStackClient` function, such as `headers` for SSR authentication if plugins expose lifecycle hooks.

      This pattern allows you to pass the appropriate QueryClient and other options for each context. 
    </Callout>
  </Step>

  <Step>
    ### Set Up Query Client Provider

    If you don't already have a query client utility, create one to ensure proper SSR hydration:

    ```ts title="lib/query-client.ts"
    import { QueryClient, isServer } from "@tanstack/react-query"
    import { cache } from "react"

    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: isServer ? 60 * 1000 : 0,
            refetchOnMount: false,
            refetchOnWindowFocus: false,
            retry: false
          },
          dehydrate: {
            // Include both successful and error states to avoid refetching on the client
            // This prevents loading states when there's an error in prefetched data
            shouldDehydrateQuery: (query) => {
                return true
            }
          }
        }
      })
    }

    let browserQueryClient: QueryClient | undefined = undefined

    export function getOrCreateQueryClient() {
        if (isServer) {
            // Server: always make a new query client
            return makeQueryClient();
        } else {
            // Browser: make a new query client if we don't already have one
            // This is very important, so we don't re-make a new client if React
            // suspends during the initial render. This may not be needed if we
            // have a suspense boundary BELOW the creation of the query client
            if (!browserQueryClient) browserQueryClient = makeQueryClient();
            return browserQueryClient;
        }
    }
    ```

    Then configure `QueryClientProvider` in your your app:

    <Tabs groupId="frameworks" items={["next-js", "react-router", "tanstack"]} persist>
      <Tab value="next-js">
        ```tsx title="app/layout.tsx"
        import { QueryClientProvider } from "@tanstack/react-query"
        import { getOrCreateQueryClient } from "@/lib/query-client"

        export default function RootLayout({ children }) {
          const queryClient = getOrCreateQueryClient()
          
          return (
            <html>
              <body>
                <QueryClientProvider client={queryClient}>
                  {children}
                </QueryClientProvider>
              </body>
            </html>
          )
        }
        ```
      </Tab>

      <Tab value="react-router">
        ```tsx title="app/root.tsx"
        import { QueryClientProvider } from "@tanstack/react-query"
        import { getOrCreateQueryClient } from "~/lib/query-client"
        import { Outlet } from "react-router"

        export default function App() {
          const queryClient = getOrCreateQueryClient()
          
          return (
            <QueryClientProvider client={queryClient}>
              <Outlet />
            </QueryClientProvider>
          )
        }
        ```
      </Tab>

      <Tab value="tanstack">
        ```tsx title="src/router.tsx"
        import { createRouter } from '@tanstack/react-router'
        import { routeTree } from './routeTree.gen'
        import { QueryClient } from '@tanstack/react-query'
        import { setupRouterSsrQueryIntegration } from '@tanstack/react-router-ssr-query'
        import { getOrCreateQueryClient } from '@/lib/query-client'

        export interface MyRouterContext {
          queryClient: QueryClient
        }

        export function getRouter() {
          const queryClient = getOrCreateQueryClient()
          
          const router = createRouter({
            routeTree,
            scrollRestoration: true,
            defaultPreload: false,
            context: {
              queryClient,
            },
            notFoundMode: "root",
          })

          setupRouterSsrQueryIntegration({
            router,
            queryClient,
          })

          return router
        }

        declare module '@tanstack/react-router' {
          interface Register {
            router: ReturnType<typeof getRouter>
          }
        }
        ```
      </Tab>
    </Tabs>

    <Callout type="info">
      The `getOrCreateQueryClient()` utility ensures:
      - **Server**: Each request gets its own QueryClient
      - **Client**: A singleton QueryClient prevents recreation during React Suspense
      - **Hydration**: Server-prefetched data seamlessly transfers to the client

      **Note**: QueryClient might have to be configured differently in your framework of choice. See [Example Projects](#example-projects) or [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/react/overview) for more details.
    </Callout>
  </Step>


  <Step>
    ### Set Up Layout Provider

    Wrap your BTST pages with the `StackProvider` to enable framework-specific overrides:

    <Tabs groupId="frameworks" items={["next-js", "react-router", "tanstack"]} persist>
      <Tab value="next-js">
        ```tsx title="app/pages/[[...all]]/layout.tsx"
        import { StackProvider } from "@btst/stack/context"
        import type { ExamplePluginOverrides } from "@btst/stack/plugins/example/client"
        import Link from "next/link"
        import Image from "next/image"
        import { useRouter } from "next/navigation"

        // Define the shape of all plugin overrides for type safety
        type PluginOverrides = {
          example: ExamplePluginOverrides
          // Add other plugins here
        }

        export default function Layout({ children }) {
          const router = useRouter()
          
          return (
            <StackProvider<PluginOverrides>
              basePath="/pages"
              overrides={{
                example: {
                  Link: (props) => <Link {...props} />,
                  Image: (props) => <Image {...props} />,
                  navigate: (path) => router.push(path),
                  // Add other plugin overrides here
                }
                // Add other plugins here
              }}
            >
              {children}
            </StackProvider>
          )
        }
        ```
      </Tab>

      <Tab value="react-router">
        ```tsx title="app/routes/pages/_layout.tsx"
        import { Outlet, Link, useNavigate } from "react-router"
        import { StackProvider } from "@btst/stack/context"
        import type { ExamplePluginOverrides } from "@btst/stack/plugins/example/client"

        // Define the shape of all plugin overrides
        type PluginOverrides = {
          example: ExamplePluginOverrides
          // Add other plugins here
        }

        export default function Layout() {
          const navigate = useNavigate()
          
          return (
            <StackProvider<PluginOverrides>
              basePath="/pages"
              overrides={{
                example: {
                  navigate: (href) => navigate(href),
                  Link: ({ href, children, className, ...props }) => (
                    <Link to={href || ""} className={className} {...props}>
                      {children}
                    </Link>
                  )
                  // Add other plugin overrides here
                }
                // Add other plugins here
              }}
            >
              <Outlet />
            </StackProvider>
          )
        }
        ```
      </Tab>

      <Tab value="tanstack">
        ```tsx title="src/routes/pages/route.tsx"
        import { StackProvider } from "@btst/stack/context"
        import { QueryClientProvider } from "@tanstack/react-query"
        import type { ExamplePluginOverrides } from "@btst/stack/plugins/example/client"
        import { Link, useRouter, Outlet, createFileRoute } from "@tanstack/react-router"

        // Define the shape of all plugin overrides
        type PluginOverrides = {
          example: ExamplePluginOverrides
          // Add other plugins here
        }

        export const Route = createFileRoute('/pages')({
          component: Layout
        })

        function Layout() {
          const router = useRouter()
          const context = Route.useRouteContext()

          return (
            <QueryClientProvider client={context.queryClient}>
              <StackProvider<PluginOverrides>
                basePath="/pages"
                overrides={{
                  example: {
                    navigate: (href) => router.navigate({ href }),
                    Link: ({ href, children, className, ...props }) => (
                      <Link to={href} className={className} {...props}>
                        {children}
                      </Link>
                    )
                    // Add other plugin overrides here
                  }
                  // Add other plugins here
                }}
              >
                <Outlet />
              </StackProvider>
            </QueryClientProvider>
          )
        }
        ```
      </Tab>
    </Tabs>

    <Callout type="info">
      **Understanding Overrides:**
      - **Purpose**: Injects framework-specific components via React Context. Plugin components access these overrides through `usePluginOverrides()` hook, allowing them to use your framework's `Link`, `Image`, and navigation without tight coupling and to avoid breaking the client/server boundary in frameworks like Next.js. 
      - **Type Safety**: Each plugin exports its override type (e.g., `ExamplePluginOverrides`)
    </Callout>
  </Step>

  <Step>
    ### Set Up Page Handler

    Create a catch-all route to handle BTST pages defined in your plugins. This enables server-side rendering, metadata generation and automatic route handling.

    <Tabs  groupId="frameworks" items={["next-js", "react-router", "tanstack"]} persist >
      <Tab value="next-js">
        ```tsx title="app/pages/[[...all]]/page.tsx"
        import { dehydrate, HydrationBoundary } from "@tanstack/react-query"
        import { notFound } from "next/navigation"
        import { getOrCreateQueryClient } from "@/lib/query-client"
        import { getStackClient } from "@/lib/stack-client"
        import { metaElementsToObject, normalizePath } from "@btst/stack/client"
        import { Metadata } from "next"

        export default async function Page({ params }: { params: Promise<{ all: string[] }> }) {
          const pathParams = await params
          const path = normalizePath(pathParams?.all)
          
          const queryClient = getOrCreateQueryClient()
          const stackClient = getStackClient(queryClient)
          const route = stackClient.router.getRoute(path)
          
          // Prefetch data server-side if the route has a loader
          if (route?.loader) await route.loader()
          
          // Serialize React Query cache for client hydration
          const dehydratedState = dehydrate(queryClient)
          
          return (
            <HydrationBoundary state={dehydratedState}>
              {route && route.PageComponent ? <route.PageComponent /> : notFound()}
            </HydrationBoundary>
          )
        }

        export async function generateMetadata({ params }: { params: Promise<{ all: string[] }> }) {
          const pathParams = await params
          const path = normalizePath(pathParams?.all)
          
          const queryClient = getOrCreateQueryClient()
          const stackClient = getStackClient(queryClient)
          const route = stackClient.router.getRoute(path)
          
          if (!route) return notFound()
          if (route?.loader) await route.loader()
          
          // Convert plugin meta elements to Next.js Metadata format
          return route.meta ? metaElementsToObject(route.meta()) satisfies Metadata : { title: "No meta" }
        }
        ```
      </Tab>

      <Tab value="react-router">
        ```tsx title="app/routes/pages/index.tsx"
        import type { Route } from "./+types/index"
        import { useLoaderData } from "react-router"
        import { dehydrate, HydrationBoundary, QueryClient, useQueryClient } from "@tanstack/react-query"
        import { getStackClient } from "~/lib/stack-client"
        import { normalizePath } from "@btst/stack/client"

        export async function loader({ params }: Route.LoaderArgs) {
          const path = normalizePath(params["*"])
          
          // Create QueryClient for this request with consistent config
          const queryClient = new QueryClient({
            defaultOptions: { queries: { staleTime: 1000 * 60 * 5, refetchOnMount: false, retry: false } }
          })
          const stackClient = getStackClient(queryClient)
          const route = stackClient.router.getRoute(path)
          
          if (route?.loader) await route.loader()
          
          // Include errors so client doesn't refetch on error
          const dehydratedState = dehydrate(queryClient)
          
          return { path, dehydratedState, meta: route?.meta?.() }
        }

        export function meta({ loaderData }: Route.MetaArgs) {
          return loaderData.meta
        }

        export default function PagesIndex() {
          const { path, dehydratedState } = useLoaderData<typeof loader>()
          const queryClient = useQueryClient()
          const route = getStackClient(queryClient).router.getRoute(path)
          const Page = route && route.PageComponent ? <route.PageComponent /> : <div>Route not found</div>
          
          return dehydratedState ? (
            <HydrationBoundary state={dehydratedState}>{Page}</HydrationBoundary>
          ) : Page
        }
        ```
      </Tab>

      <Tab value="tanstack">
        ```tsx title="src/routes/pages/$.tsx"
        import { createFileRoute, notFound } from "@tanstack/react-router"
        import { getStackClient } from "@/lib/stack-client"
        import { normalizePath } from "@btst/stack/client"

        export const Route = createFileRoute("/pages/$")({
          ssr: true,
          component: Page,
          loader: async ({ params, context }) => {
            const routePath = normalizePath(params._splat)
            const stackClient = getStackClient(context.queryClient)
            const route = stackClient.router.getRoute(routePath)
            
            if (!route) throw notFound()
            if (route?.loader) await route.loader()
            
            return { meta: await route?.meta?.() }
          },
          head: ({ loaderData }) => {
            return loaderData?.meta && Array.isArray(loaderData.meta) 
              ? { meta: loaderData.meta } 
              : { meta: [{ title: "No Meta" }], title: "No Meta" }
          },
          notFoundComponent: () => <p>This page doesn't exist!</p>
        })

        function Page() {
          const context = Route.useRouteContext()
          const { _splat } = Route.useParams()
          const routePath = normalizePath(_splat)
          const route = getStackClient(context.queryClient).router.getRoute(routePath)
          
          return route && route.PageComponent ? <route.PageComponent /> : <div>Route not found</div>
        }
        ```
      </Tab>
    </Tabs>

    <Callout type="info">
      
    **How it works:**
    
    `stackClient.router.getRoute(path)` matches the URL to a plugin route and returns a route object:
    
    ```typescript
    route = {
      PageComponent: React.ComponentType,     // The page to render
      loader?: () => Promise<void>,           // Prefetches React Query data
      meta?: () => MetadataElements,          // Returns SEO metadata
      ErrorComponent?: React.ComponentType,   // Standalone error components
      LoadingComponent?: React.ComponentType  // Standalone loading components
    }
    ```
    
    **Key steps:**
    - **Server-side data loading**: Call `route.loader()` before rendering to prefetch data into React Query cache
    - **Hydration**: Use `dehydrate()` to serialize prefetched data for the client (not required with TanStack Start)
    - **Error handling**: Configure your query client with `shouldDehydrateQuery` to include failed queries in dehydration, preventing client-side refetching on errors
    - **Metadata generation**: Use `route.meta()` with framework-specific meta functions for SEO
    - **404 handling**: Return `notFound()` or your framework's equivalent function when routes don't exist
    </Callout>

  </Step>

  <Step>
    ### Set Up Sitemap Generation (Optional)

    Create a sitemap route to enable automatic sitemap generation for SEO. The library automatically collects URLs from all registered plugins.

    **How it works**: Each plugin can export a `sitemap()` function that returns URLs with metadata (lastModified, changeFrequency, priority). The `generateSitemap()` method aggregates and deduplicates entries from all plugins.

    <Tabs groupId="frameworks" items={["next-js", "react-router", "tanstack"]} persist>
      <Tab value="next-js">
        ```ts title="app/sitemap.ts"
        import type { MetadataRoute } from "next"
        import { QueryClient } from "@tanstack/react-query"
        import { getStackClient } from "@/lib/stack-client"

        export const dynamic = "force-dynamic"

        export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
          const queryClient = new QueryClient()
          const stackClient = getStackClient(queryClient)
          return stackClient.generateSitemap()
        }
        ```
      </Tab>

      <Tab value="react-router">
        ```ts title="app/routes/sitemap.xml.ts"
        import type { Route } from "./+types/sitemap.xml"
        import { QueryClient } from "@tanstack/react-query"
        import { getStackClient } from "~/lib/stack-client"
        import { sitemapEntryToXmlString } from "@btst/stack/client"

        export async function loader({}: Route.LoaderArgs) {
          const queryClient = new QueryClient()
          const stackClient = getStackClient(queryClient)
          const entries = await stackClient.generateSitemap()
          const xml = sitemapEntryToXmlString(entries)

          return new Response(xml, {
            headers: {
              "Content-Type": "application/xml; charset=utf-8",
              "Cache-Control": "public, max-age=0, s-maxage=3600, stale-while-revalidate=86400",
            },
          })
        }
        ```
      </Tab>

      <Tab value="tanstack">
        ```ts title="src/routes/sitemap[.]xml.ts"
        // Note: [.] syntax in TanStack Router creates a route for "sitemap.xml"
        import { createFileRoute } from "@tanstack/react-router"
        import { QueryClient } from "@tanstack/react-query"
        import { getStackClient } from "@/lib/stack-client"
        import { sitemapEntryToXmlString } from "@btst/stack/client"

        export const Route = createFileRoute("/sitemap.xml")({
          server: {
            handlers: {
              GET: async () => {
                const queryClient = new QueryClient()
                const stackClient = getStackClient(queryClient)
                const entries = await stackClient.generateSitemap()
                const xml = sitemapEntryToXmlString(entries)

                return new Response(xml, {
                  headers: {
                    "Content-Type": "application/xml; charset=utf-8",
                    "Cache-Control": "public, max-age=0, s-maxage=3600, stale-while-revalidate=86400",
                  },
                })
              },
            },
          },
        })
        ```
      </Tab>
    </Tabs>

    <Callout type="info">
      The `generateSitemap()` method automatically collects URLs from all registered plugins. Each plugin can contribute its own routes to the sitemap with appropriate metadata like priority and change frequency. This step is optional but recommended for SEO.
    </Callout>
  </Step>

  <Step>
    ### ðŸŽ‰ That's it!

    Your setup is complete! Here's what you've configured:

    - âœ… Backend API handler that processes all plugin requests
    - âœ… Database adapter that connects plugins to your database
    - âœ… Client-side router with SSR support
    - âœ… React Query integration for data fetching
    - âœ… Framework-specific overrides

    **Next steps:**

    1. **Add plugins** to both backend and client configurations:
       - Backend: `plugins: { blog: blogBackendPlugin() }`
       - Client: `plugins: { blog: blogClientPlugin() }`
    
    2. **Visit your pages** at `/pages/*` to see plugin routes in action

    **Available plugins:**
    - `@btst/stack/plugins/blog` - Full-featured blog with markdown editor, SEO, and RSS. Learn more about the blog plugin [here](/plugins/blog).
    - More plugins coming soon!

    Each plugin provides everything you need: routes, API endpoints, database schemas, React components, and hooks - all working together seamlessly.

    ## Example Projects

    See complete working examples for each framework:
    - **[Next.js Example](https://github.com/better-stack-ai/better-stack/tree/main/examples/nextjs)** - Full Next.js App Router setup with blog and todo plugins
    - **[React Router Example](https://github.com/better-stack-ai/better-stack/tree/main/examples/react-router)** - React Router v7 setup with SSR support
    - **[TanStack Start Example](https://github.com/better-stack-ai/better-stack/tree/main/examples/tanstack)** - TanStack Router setup with file-based routing

    Each example includes complete configuration, plugin setup, and demonstrates framework-specific patterns.

  </Step>
</Steps>

