---
title: Database Adapters
description: Learn about database adapters and the Better Stack data layer
---

import { Tabs, Tab } from "fumadocs-ui/components/tabs";
import { Callout } from "fumadocs-ui/components/callout";

Better Stack uses a flexible adapter system that allows you to connect to any database through your preferred ORM. The adapter acts as a bridge between Better Stack's unified data layer and your database of choice.

## Package Overview

Better Stack consists of separate npm packages under the `@btst` namespace:

- **`@btst/stack`** - Core package (install this first)
- **`@btst/adapter-*`** - Database adapters (install one based on your ORM)
- **`@btst/cli`** - CLI tools for schema generation (dev dependency)
- **`@btst/db`** - Internal database abstraction layer (installed as a dependency of other packages)

See the [Installation guide](/installation) for setup instructions.

## Available Adapters

Better Stack provides official adapters for popular ORMs:

- **Prisma** - `@btst/adapter-prisma` - Supports PostgreSQL, MySQL, SQLite, CockroachDB, and MongoDB
- **Drizzle** - `@btst/adapter-drizzle` - Supports PostgreSQL, MySQL, SQLite, and more
- **Kysely** - `@btst/adapter-kysely` - Supports PostgreSQL, MySQL, SQLite, and more
- **MongoDB** - `@btst/adapter-mongodb` - Native MongoDB driver support
- **Memory** - `@btst/adapter-memory` - In-memory adapter for development and testing

## Installation

Adapters are separate packages that must be installed alongside `@btst/stack`:

```bash
# Install core package
npm install @btst/stack

# Install your chosen adapter
npm install @btst/adapter-prisma
```

See the [Installation guide](/installation#install-database-adapter) for detailed adapter setup instructions.

## Usage

When you configure Better Stack, the `betterStack()` function collects all plugin database schemas and merges them into a unified schema. The adapter function receives this merged schema and returns an adapter that translates Better Stack's database operations to your ORM.

<Tabs groupId="adapter-type" items={["prisma", "drizzle", "kysely", "mongodb", "memory"]} persist>
  <Tab value="prisma">
    ```ts title="lib/better-stack.ts"
    import { betterStack } from "@btst/stack"
    import { createPrismaAdapter } from "@btst/adapter-prisma"
    import { PrismaClient } from "@prisma/client"

    const prisma = new PrismaClient()

    const { handler, dbSchema } = betterStack({
      basePath: "/api/data",
      plugins: {
        // Your plugins here
      },
      // The adapter receives the merged db schema from all plugins
      adapter: (db) => createPrismaAdapter(prisma, db, { 
        provider: "postgresql" // or "mysql", "sqlite", "cockroachdb", "mongodb"
      })
    })

    export { handler, dbSchema }
    ```
  </Tab>

  <Tab value="drizzle">
    ```ts title="lib/better-stack.ts"
    import { betterStack } from "@btst/stack"
    import { createDrizzleAdapter } from "@btst/adapter-drizzle"
    import { drizzle } from "drizzle-orm/postgres-js" // or "drizzle-orm/mysql2", "drizzle-orm/better-sqlite3", etc.
    import postgres from "postgres"

    const client = postgres(process.env.DATABASE_URL!)
    const drizzleDb = drizzle(client)

    const { handler, dbSchema } = betterStack({
      basePath: "/api/data",
      plugins: {
        // Your plugins here
      },
      adapter: (db) => createDrizzleAdapter(drizzleDb, db, {})
    })

    export { handler, dbSchema }
    ```
  </Tab>

  <Tab value="kysely">
    ```ts title="lib/better-stack.ts"
    import { betterStack } from "@btst/stack"
    import { createKyselyAdapter } from "@btst/adapter-kysely"
    import { Kysely, PostgresDialect } from "kysely"
    import { Pool } from "pg"

    const kyselyDb = new Kysely({
      dialect: new PostgresDialect({
        pool: new Pool({ connectionString: process.env.DATABASE_URL })
      })
    })

    const { handler, dbSchema } = betterStack({
      basePath: "/api/data",
      plugins: {
        // Your plugins here
      },
      adapter: (db) => createKyselyAdapter(kyselyDb, db, {})
    })

    export { handler, dbSchema }
    ```
  </Tab>

  <Tab value="mongodb">
    ```ts title="lib/better-stack.ts"
    import { betterStack } from "@btst/stack"
    import { createMongodbAdapter } from "@btst/adapter-mongodb"
    import { MongoClient } from "mongodb"

    const client = new MongoClient(process.env.MONGODB_URI!)
    const mongoDb = client.db()

    const { handler, dbSchema } = betterStack({
      basePath: "/api/data",
      plugins: {
        // Your plugins here
      },
      adapter: (db) => createMongodbAdapter(mongoDb, db, {})
    })

    export { handler, dbSchema }
    ```
  </Tab>

  <Tab value="memory">
    ```ts title="lib/better-stack.ts"
    // IMPORTANT: Memory adapter is used for development and testing only
    import { betterStack } from "@btst/stack"
    import { createMemoryAdapter } from "@btst/adapter-memory"

    const { handler, dbSchema } = betterStack({
      basePath: "/api/data",
      plugins: {
        // Your plugins here
      },
      adapter: (db) => createMemoryAdapter(db)({})
    })

    export { handler, dbSchema }
    ```
  </Tab>
</Tabs>

The `adapter` function receives the merged database schema (`db`) containing all tables and relationships from your plugins, and returns an adapter instance that implements the common adapter interface.

<Callout type="info">
  To learn more about generating database schemas and running migrations, see the [CLI documentation](/cli).
</Callout>

### How the Adapter Function Works

The adapter pattern follows this flow:

1. `betterStack()` merges all plugin schemas into a unified `db` object
2. Your `adapter` function receives this `db` object
3. The adapter creator function (e.g., `createPrismaAdapter`, `createDrizzleAdapter`) returns an adapter instance
4. This adapter instance implements the common interface (create, update, findOne, etc.)

The adapter function signature allows the adapter to be configured with both Better Stack's schema and any ORM-specific options.

## Database Schema Generation

After configuring your adapter, you'll need to generate database schemas and migrations. Better Stack provides a CLI tool to help with this process.

See the [CLI documentation](/cli) for detailed information on generating schemas for Prisma, Drizzle, and Kysely, as well as running migrations.

## How Data Layer Works

Better Stack's data layer is built on [Better DB](https://github.com/better-stack-ai/better-auth/tree/main/packages/btst), a fork of better-auth's database layer. Better DB is a type-safe database abstraction layer that provides:

- **Unified Schema Definition**: Plugins define their database schemas using Better DB's schema definition API
- **Schema Composition**: All plugin schemas are automatically merged into a single unified schema
- **Type-Safe Operations**: Full TypeScript support for all database operations
- **Adapter Abstraction**: Works with any database through adapters

### How Adapters Work

Adapters implement a common interface that provides methods for:
- `create` - Insert new records
- `update` - Update existing records
- `updateMany` - Bulk update operations
- `delete` - Delete records
- `deleteMany` - Bulk delete operations
- `findOne` - Find a single record (supports `join` option)
- `findMany` - Query multiple records (supports `join` option)
- `count` - Count records matching criteria

Each adapter translates these operations to the appropriate ORM calls (Prisma, Drizzle, Kysely, MongoDB, etc.).

## Relational Queries with Join

Adapters support a `join` option for `findOne` and `findMany` operations, allowing you to fetch related records in a single query.

### Defining Foreign Key Relationships

To use joins, you must define foreign key relationships in your schema using the `references` property:

```ts title="db/schema.ts"
import { createDbPlugin } from "@btst/db";

export const mySchema = createDbPlugin("myPlugin", {
  post: {
    modelName: "post",
    fields: {
      title: { type: "string", required: true },
      // ... other fields
    },
  },
  tag: {
    modelName: "tag",
    fields: {
      name: { type: "string", required: true },
      // ... other fields
    },
  },
  postTag: {
    modelName: "postTag",
    fields: {
      postId: {
        type: "string",
        required: true,
        references: {
          model: "post",
          field: "id",
          onDelete: "cascade", // Optional: automatically delete when parent is deleted
        },
      },
      tagId: {
        type: "string",
        required: true,
        references: {
          model: "tag",
          field: "id",
          onDelete: "cascade",
        },
      },
    },
  },
});
```

### Using the Join Option

Once relationships are defined, you can use the `join` option to fetch related records:

```ts
// Fetch posts with their related postTag records
const posts = await adapter.findMany<Post & { postTag?: PostTag[] }>({
  model: "post",
  where: [{ field: "published", value: true }],
  join: {
    postTag: true, // Join the postTag model
  },
});

// Each post will have a `postTag` array with related records
posts.forEach(post => {
  console.log(post.title, post.postTag);
});
```

### Join Option Configuration

The `join` option accepts an object where keys are model names and values configure the join:

```ts
type JoinOption = {
  [model: string]: boolean | {
    limit?: number; // Limit the number of joined records
  };
};
```

Examples:

```ts
// Simple join - fetch all related records
join: { postTag: true }

// Limited join - fetch only first 5 related records
join: { postTag: { limit: 5 } }
```

### Cascade Delete

When you define `onDelete: "cascade"` on a foreign key reference, deleting the parent record will automatically delete all related child records:

```ts
// With cascade delete defined, this single operation
// also deletes all related postTag records automatically
await adapter.delete({
  model: "post",
  where: [{ field: "id", value: postId }],
});
```

Available `onDelete` options:
- `"cascade"` - Delete child records when parent is deleted
- `"set null"` - Set the foreign key to null when parent is deleted
- `"restrict"` - Prevent deletion if child records exist
- `"no action"` - No automatic action (database default)
- `"set default"` - Set the foreign key to its default value

## Using Other Better Auth Compatible Adapters

Better DB is a fork of better-auth's database layer, which means existing [better-auth adapters](https://www.better-auth.com/docs/concepts/database) can work with Better Stack with a small wrapper modification. The wrapper is necessary because Better Stack's plugin system merges schemas differently than better-auth plugins.

This allows you to leverage the wide ecosystem of better-auth adapters. The wrapper function needs to inject the Better DB schema into the better-auth adapter's plugin system so it can find your models. Here's an example of how `@btst/adapter-prisma` wraps better-auth's Prisma adapter:

```ts title="lib/adapters/prisma.ts"

export * from "better-auth/adapters/prisma";

import type { Adapter, DatabaseDefinition } from "@btst/db";
import { prismaAdapter, type PrismaConfig } from "better-auth/adapters/prisma";
import type { BetterAuthOptions } from "better-auth/types";

/**
 * Helper function to create a Prisma adapter with Better DB schema
 *
 * This handles passing the Better DB schema to the prismaAdapter
 * by injecting it as a plugin so Better Auth can find your models.
 */
export function createPrismaAdapter(
	prisma: any,
	db: DatabaseDefinition,
	config: PrismaConfig,
	options: BetterAuthOptions = {},
): (options: BetterAuthOptions) => Adapter {
	return (adapterOptions: BetterAuthOptions = {}) => {
		const mergedOptions = {
			...options,
			...adapterOptions,
			plugins: [
				...(options.plugins || []),
				...(adapterOptions.plugins || []),
				{
					id: "better-db-schema",
					schema: db.getSchema(),
				},
			],
		};
		return prismaAdapter(prisma, config)(mergedOptions);
	};
}
```

You can apply the same pattern to wrap other better-auth compatible adapters that are currently not exported by better-db.

## Better DB Package

Better DB is a fork of [better-auth](https://www.better-auth.com)'s database layer. For more information about the underlying data layer, see the [Better DB package](https://github.com/better-stack-ai/better-auth/tree/main/packages/btst) on GitHub. This package provides the core database abstraction that powers Better Stack's adapter system.
